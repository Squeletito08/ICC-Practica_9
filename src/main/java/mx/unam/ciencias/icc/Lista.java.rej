--- src/main/java/mx/unam/ciencias/icc/Lista.java
+++ src/main/java/mx/unam/ciencias/icc/Lista.java
@@ -30,7 +30,7 @@ public class Lista<T> implements Iterable<T> {
 
         /* Construye un nodo con un elemento. */
         private Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento; 
         }
     }
 
@@ -43,37 +43,47 @@ public class Lista<T> implements Iterable<T> {
 
         /* Construye un nuevo iterador. */
         private Iterador() {
-            // Aquí va su código.
+            start(); 
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return siguiente != null; 
         }
 
         /* Nos da el elemento siguiente. */
         @Override public T next() {
-            // Aquí va su código.
+            if(!hasNext())
+                throw new NoSuchElementException(); 
+            anterior = siguiente; 
+            siguiente = siguiente.siguiente; 
+            return anterior.elemento;    
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
-            // Aquí va su código.
+            return anterior != null; 
         }
 
         /* Nos da el elemento anterior. */
         @Override public T previous() {
-            // Aquí va su código.
+            if(!hasPrevious())
+                throw new NoSuchElementException(); 
+            siguiente = anterior; 
+            anterior = anterior.anterior; 
+            return siguiente.elemento; 
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
-            // Aquí va su código.
+            anterior = null; 
+            siguiente = cabeza; 
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
-            // Aquí va su código.
+            siguiente = null; 
+            anterior = rabo; 
         }
     }
 
@@ -84,12 +94,12 @@ public class Lista<T> implements Iterable<T> {
     /* Número de elementos en la lista. */
     private int longitud;
 
-    /**
+   /**
      * Regresa la longitud de la lista.
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
-        // Aquí va su código.
+        return longitud; 
     }
 
     /**
@@ -98,7 +108,10 @@ public class Lista<T> implements Iterable<T> {
      *         otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        if(cabeza == null)
+            return true; 
+
+        return false;         
     }
 
     /**
@@ -109,7 +122,21 @@ public class Lista<T> implements Iterable<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+
+        Nodo nodo = new Nodo(elemento);
+        longitud++; 
+        if(esVacia()){
+            cabeza = nodo; 
+            rabo = nodo;
+        }
+        else{
+            rabo.siguiente = nodo; 
+            nodo.anterior = rabo; 
+            rabo = nodo; 
+        }
+        return; 
     }
 
     /**
@@ -120,7 +147,22 @@ public class Lista<T> implements Iterable<T> {
      *         <code>null</code>.
      */
     public void agregaInicio(T elemento) {
-        // Aquí va su código.
+
+        if (elemento == null)
+            throw new IllegalArgumentException();
+
+        Nodo nodo = new Nodo(elemento); 
+        longitud++; 
+        if(esVacia()){
+            cabeza = nodo; 
+            rabo = nodo;
+        }
+        else{
+            cabeza.anterior = nodo; 
+            nodo.siguiente = cabeza; 
+            cabeza = nodo;
+        }
+        return;         
     }
 
     /**
@@ -139,7 +181,34 @@ public class Lista<T> implements Iterable<T> {
      *         <code>null</code>.
      */
     public void inserta(int i, T elemento) {
-        // Aquí va su código.
+        if(elemento == null)
+            throw new IllegalArgumentException();  
+
+        if (i < 1){
+            agregaInicio(elemento);
+        }
+        else if(i > longitud - 1){
+            agregaFinal(elemento);
+        }
+        else{
+            Nodo nodoAux;
+            nodoAux = buscaNodo(i);
+
+            if(nodoAux == null)
+                return; 
+
+            Nodo nodoE = new Nodo(elemento);
+
+            longitud++; 
+
+            Nodo nodoAuxAnterior = nodoAux.anterior; 
+
+            nodoAux.anterior = nodoE; 
+            nodoE.siguiente = nodoAux; 
+            nodoAuxAnterior.siguiente = nodoE; 
+            nodoE.anterior = nodoAuxAnterior;
+        return;
+        }        
     }
 
     /**
@@ -148,16 +217,93 @@ public class Lista<T> implements Iterable<T> {
      * @param elemento el elemento a eliminar.
      */
     public void elimina(T elemento) {
-        // Aquí va su código.
+        if(elemento == null)
+            return;
+        if(esVacia())
+            return; 
+
+        Nodo nodo = buscaNodo(elemento);
+
+        if(nodo == null)
+            return;
+
+        eliminaNodo(nodo);
+        return;         
+    }
+
+    // metodo buscaNodo que recibe como parametro un entero
+    private Nodo buscaNodo(int i){
+
+        if(esVacia())
+            return null; 
+        
+        if(i < 0 || i > longitud - 1)
+            return null; 
+
+        Nodo nodo; 
+        int contador = 0; 
+        nodo = cabeza; 
+        while(contador < i){
+            contador++;
+            nodo = nodo.siguiente;
+        }
+        return nodo; 
+    }
+
+    // metodo buscaNodo que recibe como parametro un Estudiante 
+    private Nodo buscaNodo(Object e){
+        if(e == null)
+            return null; 
+
+        if(esVacia())
+            return null;        
+
+        Nodo aux;
+        aux = cabeza;  
+
+        while(aux != null && !aux.elemento.equals(e)){
+            aux = aux.siguiente; 
+        }
+        return aux; 
+    }
+
+
+    private void eliminaNodo(Nodo nodo){
+
+        longitud--; 
+
+        if(cabeza == rabo){
+            cabeza = null; 
+            rabo = null; 
+        }
+        else if(nodo == cabeza){
+            cabeza.siguiente.anterior = null; 
+            cabeza = nodo.siguiente;  
+        }
+        else if(nodo == rabo){
+            rabo.anterior.siguiente = null; 
+            rabo = nodo.anterior;
+        }
+        else{
+            nodo.siguiente.anterior = nodo.anterior; 
+            nodo.anterior.siguiente = nodo.siguiente;    
+        }
+        return; 
     }
 
+
     /**
      * Elimina el primer elemento de la lista y lo regresa.
      * @return el primer elemento de la lista antes de eliminarlo.
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaPrimero() {
-        // Aquí va su código.
+        if(esVacia())
+            throw new NoSuchElementException();
+
+        T aux = cabeza.elemento; 
+        eliminaNodo(cabeza);
+        return aux;     
     }
 
     /**
@@ -166,7 +312,12 @@ public class Lista<T> implements Iterable<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaUltimo() {
-        // Aquí va su código.
+        if(esVacia())
+            throw new NoSuchElementException();
+
+        T aux = rabo.elemento;
+        eliminaNodo(rabo);
+        return aux;         
     }
 
     /**
@@ -176,7 +327,7 @@ public class Lista<T> implements Iterable<T> {
      *         <code>false</code> en otro caso.
      */
     public boolean contiene(T elemento) {
-        // Aquí va su código.
+        return buscaNodo(elemento) != null;
     }
 
     /**
@@ -184,7 +335,18 @@ public class Lista<T> implements Iterable<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
-        // Aquí va su código.
+        Lista<T> listaReversa = new Lista<T>();
+
+        Nodo auxiliar = cabeza; 
+        
+        int contador = 0; 
+        while(contador < longitud){
+            listaReversa.agregaInicio(auxiliar.elemento);
+            auxiliar = auxiliar.siguiente;
+            contador++;
+        } 
+
+        return listaReversa;  
     }
 
     /**
@@ -193,14 +355,27 @@ public class Lista<T> implements Iterable<T> {
      * @return una copiad de la lista.
      */
     public Lista<T> copia() {
-        // Aquí va su código.
+        Lista<T> listaCopia = new Lista<T>();
+
+        Nodo auxiliar = cabeza; 
+
+        int contador = 0; 
+        while(contador < longitud){
+            listaCopia.agregaFinal(auxiliar.elemento);
+            auxiliar = auxiliar.siguiente;
+            contador++;
+        } 
+        return listaCopia; 
     }
 
     /**
      * Limpia la lista de elementos, dejándola vacía.
      */
     public void limpia() {
-        // Aquí va su código.
+        cabeza = null; 
+        rabo = null; 
+        longitud = 0;
+        return;        
     }
 
     /**
@@ -209,7 +384,10 @@ public class Lista<T> implements Iterable<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getPrimero() {
-        // Aquí va su código.
+        if(esVacia())
+            throw new NoSuchElementException();
+
+        return cabeza.elemento;
     }
 
     /**
@@ -218,7 +396,10 @@ public class Lista<T> implements Iterable<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getUltimo() {
-        // Aquí va su código.
+        if(esVacia())
+            throw new NoSuchElementException();
+
+        return rabo.elemento;
     }
 
     /**
@@ -229,7 +410,16 @@ public class Lista<T> implements Iterable<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
-        // Aquí va su código.
+        if(esVacia())
+            throw new NoSuchElementException(); 
+
+        if(i >= longitud || i < 0)
+            throw new ExcepcionIndiceInvalido(); 
+
+        Nodo auxiliar = buscaNodo(i);
+        if(auxiliar == null)
+            return null; 
+        return auxiliar.elemento; 
     }
 
     /**
@@ -239,7 +429,20 @@ public class Lista<T> implements Iterable<T> {
      *         no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
-        // Aquí va su código.
+        if(esVacia())
+            return -1;   
+       
+        Nodo auxiliar;
+        auxiliar = cabeza; 
+
+        int contador = 0; 
+        while(contador < longitud){
+            if(auxiliar.elemento.equals(elemento))
+                return contador; 
+            auxiliar = auxiliar.siguiente;
+            contador++; 
+        }
+        return -1;          
     }
 
     /**
@@ -247,7 +450,29 @@ public class Lista<T> implements Iterable<T> {
      * @return una representación en cadena de la lista.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        if(esVacia()){
+            return "[]";
+        }
+
+        Nodo auxiliar = cabeza;
+
+        StringBuffer sb = new StringBuffer();
+
+        sb.append("[").append(auxiliar.elemento);
+
+        if(auxiliar == null)
+            return "[]";
+
+        while(auxiliar != rabo){
+            sb.append(", ");
+            auxiliar = auxiliar.siguiente;   
+            if(auxiliar == null)
+                break;
+            sb.append(auxiliar.elemento);
+        }
+        sb.append("]");
+
+        return sb.toString();   
     }
 
     /**
@@ -260,9 +485,22 @@ public class Lista<T> implements Iterable<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
-        // Aquí va su código.
+
+        if (lista == null || longitud != lista.longitud)
+            return false;
+
+        Lista<T>.Nodo n1 = cabeza;
+        Lista<T>.Nodo n2 = lista.cabeza;
+        while (n1 != null && n2 != null) {
+            if (!n1.elemento.equals(n2.elemento))
+                return false;
+            n1 = n1.siguiente;
+            n2 = n2.siguiente;
+        }
+        return true;
     }
 
+
     /**
      * Regresa un iterador para recorrer la lista en una dirección.
      * @return un iterador para recorrer la lista en una dirección.
@@ -279,6 +517,7 @@ public class Lista<T> implements Iterable<T> {
         return new Iterador();
     }
 
+
     /**
      * Regresa una copia de la lista, pero ordenada. Para poder hacer el
      * ordenamiento, el método necesita una instancia de {@link Comparator} para
@@ -287,8 +526,61 @@ public class Lista<T> implements Iterable<T> {
      *                   ordenamiento.
      * @return una copia de la lista, pero ordenada.
      */
+
+    
     public Lista<T> mergeSort(Comparator<T> comparador) {
-        // Aquí va su código.
+        if(longitud <= 1){
+            return copia();
+
+        }
+        Lista<T> l1 = new Lista<T>(); 
+        Nodo aux = cabeza; 
+        Nodo mitad = buscaNodo((longitud-1)/2 + 1);
+
+        while(aux != mitad){
+            l1.agregaFinal(aux.elemento);
+            aux = aux.siguiente; 
+        }
+
+
+        Lista<T> l2 = new Lista<T>(); 
+        while(mitad != null){
+            l2.agregaFinal(mitad.elemento);
+            mitad = mitad.siguiente;
+        }
+
+        l1 = l1.mergeSort(comparador);
+        l2 = l2.mergeSort(comparador);
+        return mezcla(comparador,l1,l2);
+    }
+
+
+    private Lista<T> mezcla(Comparator<T> comparador, Lista<T> l1, Lista<T> l2){
+        Lista<T> lista = new Lista<T>();
+        Nodo i = l1.cabeza; 
+        Nodo j = l2.cabeza; 
+
+        while(i != null && j != null){
+            if(comparador.compare(i.elemento,j.elemento) <= 0){
+                lista.agregaFinal(i.elemento);
+                i = i.siguiente; 
+            }
+            else{
+                lista.agregaFinal(j.elemento);
+                j = j.siguiente; 
+            }
+        }
+
+        while(i != null){
+            lista.agregaFinal(i.elemento);
+            i = i.siguiente;
+        }
+        while(j != null){
+            lista.agregaFinal(j.elemento);
+            j = j.siguiente; 
+        }
+
+        return lista;   
     }
 
     /**
@@ -312,9 +604,20 @@ public class Lista<T> implements Iterable<T> {
      * @return <code>true</code> si el elemento está contenido en la lista,
      *         <code>false</code> en otro caso.
      */
+    
     public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+        Nodo aux = cabeza; 
+        while(aux != null){
+            if(comparador.compare(elemento,aux.elemento) < 0)
+                return false;
+            if(comparador.compare(elemento,aux.elemento) == 0)
+                return true; 
+            
+            aux = aux.siguiente; 
+        }
+        return false;    
     }
+    
 
     /**
      * Busca un elemento en una lista ordenada. La lista recibida tiene que
